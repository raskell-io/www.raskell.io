<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content=dark name=theme-color><title>Mise ate my Makefile | Raskell</title><link href=https://raskell.io/rss.xml rel=alternate title=RSS type=application/rss+xml><meta content="Raskell | Tech web space curated by Raffael" property=og:site_name><meta content="Mise ate my Makefile | Raskell" property=og:title><meta content="Mise ate my Makefile | Raskell" itemprop=name><meta content="Mise ate my Makefile | Raskell" name=twitter:title><meta content="Mise ate my Makefile | Raskell" name=application-name><meta content=summary name=twitter:card><meta content="How a single Rust tool replaced both make and asdf in my projects, bringing fuzzy matching, encryption, and actual sanity to task running." name=description><meta content="How a single Rust tool replaced both make and asdf in my projects, bringing fuzzy matching, encryption, and actual sanity to task running." name=twitter:description><meta content="How a single Rust tool replaced both make and asdf in my projects, bringing fuzzy matching, encryption, and actual sanity to task running." itemprop=description><meta content="How a single Rust tool replaced both make and asdf in my projects, bringing fuzzy matching, encryption, and actual sanity to task running." property=og:description><meta content=article property=og:type><meta content=Raffael property=article:author><meta content=2025-12-14 property=article:published_time><link rel="shortcut icon" href=https://raskell.io/raskell-mascot.avif type=image/x-icon><link href=https://raskell.io/style.css rel=stylesheet><script>(()=>{const a=`ThemeColorScheme`;const b=`auto`;if(!localStorage.getItem(a)){localStorage.setItem(a,b)}})()</script><script>(()=>{let d=`dark`;const a=`ThemeColorScheme`;const b=localStorage.getItem(a);const c=window.matchMedia(`(prefers-color-scheme: dark)`).matches===!0;if(b==d||b===`auto`&&c){document.documentElement.dataset.userColorScheme=d}else{document.documentElement.dataset.userColorScheme=`light`}})()</script><body class=dark><nav class=navbar><div class=container><div class=flex><div><a class=brand href=https://raskell.io> <img alt="Raskell logo" class=brand-logo src=https://raskell.io/raskell-mascot.avif> <span class=brand-text>Raskell</span> </a></div><div class=flex><a href=https://raskell.io/articles/>Articles</a><a href=https://raskell.io/projects/>Projects</a><a href=https://raskell.io/speaking/>Speaking</a><a href=https://raskell.io/about/>About</a><button aria-label="Toggle theme" title="Toggle light/dark theme" id=dark-mode-button><div class=theme-toggle-inner><svg viewbox="0 0 24 24" class=sun-icon fill=none height=20 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=20><circle cx=12 cy=12 r=5></circle><line x1=12 x2=12 y1=1 y2=3></line><line x1=12 x2=12 y1=21 y2=23></line><line x1=4.22 x2=5.64 y1=4.22 y2=5.64></line><line x1=18.36 x2=19.78 y1=18.36 y2=19.78></line><line x1=1 x2=3 y1=12 y2=12></line><line x1=21 x2=23 y1=12 y2=12></line><line x1=4.22 x2=5.64 y1=19.78 y2=18.36></line><line x1=18.36 x2=19.78 y1=5.64 y2=4.22></line></svg><svg viewbox="0 0 24 24" class=moon-icon fill=none height=20 stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 width=20><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></div></button></div></div></div></nav><main><div class=container><article><header class=article-header><div class=thumb><div><h1>Mise ate my Makefile</h1><div class=post-meta><div class=meta-line><span class=author>Raffael</span><span class=separator>·</span><time>December 14, 2025</time><span class=separator>·</span><span class=reading-time>4 min read</span></div><div class=article-taxonomies><div class=tags><a class=tag href=https://raskell.io/tags/oss/>oss</a><a class=tag href=https://raskell.io/tags/rust/>rust</a><a class=tag href=https://raskell.io/tags/dev-ex/>dev-ex</a></div></div></div></div></div><img alt="Mise ate my Makefile" class=post-thumbnail decoding=async loading=lazy src=/mise-ate-make.avif></header></article><div class=article-post><h2 id=the-problem-with-project-setup>The problem with project setup</h2><p>Every project starts the same. You need Ruby 3.2.1 but have 2.7. You need Node 20 but have 18. Someone wrote a Makefile that assumes GNU make but you’re on BSD. The <code>scripts/</code> folder has 47 shell scripts and nobody remembers what half of them do.<p>I found mise. It fixed all of this.<h2 id=what-mise-actually-is>What mise actually is</h2><p>mise started as a Rust rewrite of asdf. Then it absorbed make’s job too. Now it’s the one tool I install on every machine.<p>Here’s what my typical project setup looked like before:<ul><li><code>.ruby-version</code> for rbenv<li><code>.nvmrc</code> for node<li><code>Makefile</code> with 20 targets<li><code>scripts/</code> with random shell scripts<li><code>.env.example</code> that nobody updates</ul><p>Here’s what it looks like now:<pre class=language-toml data-lang=toml style=color:#d8dee9;background-color:#2e3440><code class=language-toml data-lang=toml><span style=color:#616e88># .mise.toml
</span><span>[tools]
</span><span style=color:#81a1c1>ruby </span><span>= </span><span style=color:#a3be8c>"3.2.1"
</span><span style=color:#81a1c1>node </span><span>= </span><span style=color:#a3be8c>"20.11.0"
</span><span style=color:#81a1c1>python </span><span>= </span><span style=color:#a3be8c>"3.12"
</span><span>
</span><span>[tasks</span><span style=color:#eceff4>.</span><span>test]
</span><span style=color:#81a1c1>run </span><span>= </span><span style=color:#a3be8c>"bundle exec rspec && npm test"
</span><span style=color:#81a1c1>description </span><span>= </span><span style=color:#a3be8c>"Run all tests"
</span><span>
</span><span>[tasks</span><span style=color:#eceff4>.</span><span>deploy]
</span><span style=color:#81a1c1>run </span><span>= </span><span style=color:#a3be8c>"kubectl apply -f k8s/"
</span><span style=color:#81a1c1>depends </span><span>= [</span><span style=color:#a3be8c>"test"</span><span style=color:#eceff4>, </span><span style=color:#a3be8c>"build"</span><span>]
</span><span>
</span><span>[env]
</span><span style=color:#81a1c1>DATABASE_URL </span><span>= </span><span style=color:#a3be8c>"postgresql://localhost/myapp_dev"
</span><span style=color:#81a1c1>RAILS_ENV </span><span>= </span><span style=color:#a3be8c>"development"
</span></code></pre><p>One file. Everything works.<h2 id=the-fuzzy-matching-that-actually-works>The fuzzy matching that actually works</h2><p>This is where mise gets interesting. You don’t need exact command names.<pre class=language-bash data-lang=bash style=color:#d8dee9;background-color:#2e3440><code class=language-bash data-lang=bash><span style=color:#88c0d0>$</span><span> mise run test     </span><span style=color:#616e88># runs the test task
</span><span style=color:#88c0d0>$</span><span> mise run tset     </span><span style=color:#616e88># still runs test (typo forgiven)
</span><span style=color:#88c0d0>$</span><span> mise run tst      </span><span style=color:#616e88># yep, runs test
</span><span style=color:#88c0d0>$</span><span> mise run deploy   </span><span style=color:#616e88># runs deploy task
</span><span style=color:#88c0d0>$</span><span> mise run dply     </span><span style=color:#616e88># runs deploy
</span></code></pre><p>The fuzzy matching is smart. It weighs:<ul><li>Character position (earlier matches score higher)<li>Consecutive matches<li>Word boundaries</ul><p>I tested this with 30+ tasks in one project. It still found the right one 90% of the time with 3-4 characters.<h2 id=tasks-live-where-they-should>Tasks live where they should</h2><p>Instead of polluting the root with <code>scripts/</code>, mise looks in <code>.mise/tasks/</code>:<pre class=language-bash data-lang=bash style=color:#d8dee9;background-color:#2e3440><code class=language-bash data-lang=bash><span style=color:#88c0d0>.mise/
</span><span style=color:#88c0d0>└──</span><span> tasks/
</span><span>    </span><span style=color:#88c0d0>├──</span><span> db-reset.sh
</span><span>    </span><span style=color:#88c0d0>├──</span><span> cache-clear.sh
</span><span>    </span><span style=color:#88c0d0>└──</span><span> logs-tail.sh
</span></code></pre><p>Any executable in there becomes a task. No registration. No config.<pre class=language-bash data-lang=bash style=color:#d8dee9;background-color:#2e3440><code class=language-bash data-lang=bash><span style=color:#88c0d0>$</span><span> mise run db-reset    </span><span style=color:#616e88># runs .mise/tasks/db-reset.sh
</span><span style=color:#88c0d0>$</span><span> mise run cache       </span><span style=color:#616e88># fuzzy matches to cache-clear.sh
</span></code></pre><p>Shell scripts stay shell scripts. But now they’re discoverable:<pre class=language-bash data-lang=bash style=color:#d8dee9;background-color:#2e3440><code class=language-bash data-lang=bash><span style=color:#88c0d0>$</span><span> mise tasks
</span><span style=color:#88c0d0>cache-clear</span><span>   Clear all caches
</span><span style=color:#88c0d0>db-reset</span><span>      Reset database to clean state  
</span><span style=color:#88c0d0>logs-tail</span><span>     Tail production logs
</span><span style=color:#88c0d0>test</span><span>          Run all tests
</span><span style=color:#88c0d0>deploy</span><span>        Deploy to production
</span></code></pre><h2 id=the-encryption-bit-that-matters>The encryption bit that matters</h2><p>mise includes age encryption support. Not bolted on. Built in.<pre class=language-toml data-lang=toml style=color:#d8dee9;background-color:#2e3440><code class=language-toml data-lang=toml><span style=color:#616e88># .mise.toml
</span><span>[env]
</span><span style=color:#81a1c1>DATABASE_URL </span><span>= </span><span style=color:#a3be8c>"postgresql://localhost/dev"
</span><span style=color:#81a1c1>API_KEY </span><span>= </span><span style=color:#a3be8c>"age:SECRET_ENCRYPTED_STRING"
</span></code></pre><p>Set it up once:<pre class=language-bash data-lang=bash style=color:#d8dee9;background-color:#2e3440><code class=language-bash data-lang=bash><span style=color:#88c0d0>$</span><span> mise decrypt .mise.toml
</span><span style=color:#88c0d0>Enter</span><span> passphrase: 
</span><span style=color:#88c0d0>$</span><span> export API_KEY=</span><span style=color:#a3be8c>"actual-secret-key"
</span><span style=color:#88c0d0>$</span><span> mise encrypt .mise.toml
</span></code></pre><p>Your secrets are in the repo but encrypted. CI/CD gets the age key. Developers get the age key. Random GitHub scrapers get nothing.<h2 id=integration-with-zed>Integration with Zed</h2><p>This is where it gets smooth. In Zed, I set up task shortcuts:<pre class=language-json data-lang=json style=color:#d8dee9;background-color:#2e3440><code class=language-json data-lang=json><span style=color:#616e88>// .zed/tasks.json
</span><span>{
</span><span>  </span><span style=color:#a3be8c>"tasks"</span><span style=color:#eceff4>: </span><span>{
</span><span>    </span><span style=color:#a3be8c>"test"</span><span style=color:#eceff4>: </span><span>{
</span><span>      </span><span style=color:#a3be8c>"command"</span><span style=color:#eceff4>: </span><span style=color:#a3be8c>"mise run test"</span><span style=color:#eceff4>,
</span><span>      </span><span style=color:#a3be8c>"cwd"</span><span style=color:#eceff4>: </span><span style=color:#a3be8c>"$WORKSPACE_ROOT"
</span><span>    }</span><span style=color:#eceff4>,
</span><span>    </span><span style=color:#a3be8c>"deploy"</span><span style=color:#eceff4>: </span><span>{
</span><span>      </span><span style=color:#a3be8c>"command"</span><span style=color:#eceff4>: </span><span style=color:#a3be8c>"mise run deploy"</span><span style=color:#eceff4>,
</span><span>      </span><span style=color:#a3be8c>"cwd"</span><span style=color:#eceff4>: </span><span style=color:#a3be8c>"$WORKSPACE_ROOT"  
</span><span>    }
</span><span>  }
</span><span>}
</span></code></pre><p>Now <code>cmd-shift-t</code> opens the task picker. Type “te”, hit enter. Tests run. The AI assistant sees the output inline. Fixes the code. Reruns the test. No context switching.<h2 id=what-breaks>What breaks</h2><p>mise isn’t perfect. Here’s what I hit:<ol><li><strong>Windows support</strong>: Works through WSL. Native is rough.<li><strong>Legacy tools</strong>: Some older ruby/node versions don’t install clean. Same issue asdf has.<li><strong>Task dependencies</strong>: Can’t do dynamic dependencies like make. Tasks depend on fixed task names.<li><strong>Fuzzy matching confusion</strong>: With tasks named <code>deploy-staging</code> and <code>deploy-production</code>, typing <code>deploy</code> might pick wrong. Be specific or rename.</ol><h2 id=the-tradeoffs>The tradeoffs</h2><p>What I gained:<ul><li>One tool instead of 4 (asdf, direnv, make, scripts)<li>Fuzzy matching saves 100s of keystrokes daily<li>New devs get running in 2 commands: <code>mise install</code> and <code>mise run setup</code><li>Secrets management that doesn’t suck<li>Task discovery that actually works</ul><p>What I paid:<ul><li>Another tool to install (but it replaces 4)<li>TOML syntax (not everyone’s favorite)<li>Rewriting Makefiles (took an afternoon per project)<li>Teaching the team new patterns (took a week)</ul><h2 id=migration-pattern>Migration pattern</h2><p>If you’re moving an existing project:<ol><li>Install mise: <code>curl https://mise.jdx.dev/install.sh | sh</code><li>Import existing tool versions: <code>mise install</code><li>Move one make target at a time to mise tasks<li>Move scripts to <code>.mise/tasks/</code> gradually<li>Add encryption last (less disruption)</ol><p>Start with the most-used tasks. Leave the weird legacy stuff in make until later.<h2 id=what-i-d-do-differently>What I’d do differently</h2><p>After migrating 12 projects:<ul><li>Start with <code>.mise.toml</code>, not <code>.mise/config.yaml</code>. TOML is cleaner for this.<li>Put all tasks in <code>.mise/tasks/</code> as shell scripts first. Move to inline tasks only when needed.<li>Name tasks with clear prefixes: <code>db-reset</code>, <code>cache-clear</code>, <code>test-unit</code>. Makes fuzzy matching more predictable.<li>Document the age key setup immediately. People forget.</ul><h2 id=the-bottom-line>The bottom line</h2><p>mise replaced my entire project automation stack. The Rust rewrite isn’t just faster. It’s more thoughtful. Fuzzy matching, encrypted env vars, task discovery. These aren’t features. They’re fixes for real pain.<p>Every new project starts with <code>.mise.toml</code> now. Setup takes 5 minutes instead of an hour. New developers don’t message me asking how to run tests. They just run <code>mise tasks</code> and figure it out.<p>That’s the tool working.</div></div><div class=container><nav class="flex container suggested"><a title="Next post (newer)" href=https://raskell.io/articles/disk-space-void-linux-maintenance/ rel=next> <span>Next →</span> <strong>Disk space maintenance on Void Linux</strong> </a></nav></div></main><footer class="footer flex"><section class=container><nav class=footer-links><a href=https://raskell.io/rss.xml>RSS</a></nav></section><script src=https://raskell.io/app.js></script></footer><script src=https://raskell.io/anchors.js></script><script src=https://raskell.io/scroll-to-top.js></script>
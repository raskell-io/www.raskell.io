<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>Raskell - oss</title>
      <link>https://raskell.io</link>
      <description>Writing about platform automation, edge systems, applied security, and open standards. Building automation-first platforms that survive production reality.</description>
      <generator>Zola</generator>
      <language>en</language>
      <atom:link href="https://raskell.io/tags/oss/rss.xml" rel="self" type="application/rss+xml"/>
      <lastBuildDate>Wed, 31 Dec 2025 00:00:00 +0000</lastBuildDate>
      <item>
          <title>Looking back on 2025</title>
          <pubDate>Wed, 31 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://raskell.io/articles/looking-back-on-2025/</link>
          <guid>https://raskell.io/articles/looking-back-on-2025/</guid>
          <description xml:base="https://raskell.io/articles/looking-back-on-2025/">&lt;p&gt;I spent part of this year on the shores of Okinawa. The water there is something else entirely — this impossible azure that shifts to turquoise in the shallows, so clear you can see the coral formations from the surface. I found myself thinking about systems while I was there, the way you do when you’re floating in salt water with nothing pressing to attend to.&lt;&#x2F;p&gt;
&lt;p&gt;Between swims, I read Tim Berners-Lee’s “This is for everyone.” I’ve been building web software for over a decade now, and I thought I understood what the web was. But reading TBL’s words while watching that reef ecosystem do its thing — thousands of species in constant exchange, no central coordinator, just emergent complexity from simple rules — something shifted in how I saw it all.&lt;&#x2F;p&gt;
&lt;p&gt;The web TBL imagined was supposed to work like that reef. A commons. Many small nodes, each doing their own thing, connected through open protocols. Information flowing freely. The beauty of it wasn’t in any single node but in the connections between them, the way the whole became more than the sum of its parts. The same principle that makes a reef resilient makes a network powerful: diversity, redundancy, local adaptation.&lt;&#x2F;p&gt;
&lt;p&gt;What we built instead looks more like industrial aquaculture. Five platforms. Algorithmic monoculture. Content optimized for engagement metrics rather than usefulness. We took a system designed for decentralization and built the most centralized information infrastructure in human history.&lt;&#x2F;p&gt;
&lt;p&gt;I keep thinking about how that happened. The web itself never changed — HTTP still works the same way, HTML still does what it always did. What changed was the economics. Publishing became free, but being &lt;em&gt;found&lt;&#x2F;em&gt; became expensive. The platforms positioned themselves as the gatekeepers of attention, and suddenly you couldn’t reach people without paying the toll, whether in ad spend or in algorithmic compliance or in the slow erosion of doing whatever it took to game SEO.&lt;&#x2F;p&gt;
&lt;p&gt;The thing about monocultures is they’re efficient right up until they’re not. A reef can lose a species and adapt. A monoculture gets one disease and collapses. We’ve been watching the web’s monoculture show stress fractures for years — the enshittification of platforms, the SEO content farms drowning out signal with noise, the way social media stopped being social and started being a feed of engagement-optimized content from strangers.&lt;&#x2F;p&gt;
&lt;p&gt;Then 2025 happened, and AI started breaking things in interesting ways.&lt;&#x2F;p&gt;
&lt;p&gt;The obvious take is that AI makes the content problem worse. And superficially, that’s true — if you thought SEO spam was bad before, wait until you see what happens when generating ten thousand pages of plausible-sounding garbage costs essentially nothing. The content farms went into overdrive. Social platforms filled with synthetic engagement.&lt;&#x2F;p&gt;
&lt;p&gt;But here’s the thing I keep coming back to: maybe that’s the fever that breaks the infection.&lt;&#x2F;p&gt;
&lt;p&gt;The old economics of the web depended on a particular scarcity. Human attention is finite, and the platforms controlled access to it. You wanted eyeballs, you played their game. SEO worked because Google was the gateway and you could optimize for what Google wanted. Platform distribution mattered because that’s where the people were.&lt;&#x2F;p&gt;
&lt;p&gt;AI disrupts this in ways that I think are genuinely interesting. When an AI assistant can synthesize information from across the web and deliver it directly to the user, the value of ranking first on Google diminishes. Why click through to a content farm when the answer is already in front of you? When AI agents can find and surface relevant content directly, you don’t need to be on the platform where the eyeballs gather. The middleman’s leverage starts to evaporate.&lt;&#x2F;p&gt;
&lt;p&gt;And crucially: when everyone can generate infinite content at zero marginal cost, content quantity becomes worthless. What matters is provenance. Accuracy. Usefulness. The things that are actually hard. The things that require a human perspective, or at least require &lt;em&gt;being right&lt;&#x2F;em&gt; in ways that matter.&lt;&#x2F;p&gt;
&lt;p&gt;I find myself unexpectedly optimistic about what comes next.&lt;&#x2F;p&gt;
&lt;p&gt;If AI breaks the distribution stranglehold that platforms have, the economics of the web could flip in interesting directions. The old model needed scale because reaching people was expensive. But if AI handles discovery — finding relevant content and bringing it to users — then maybe you don’t need scale anymore. Maybe small becomes viable again.&lt;&#x2F;p&gt;
&lt;p&gt;Think about what this means concretely. A static site costs nearly nothing to run. No databases to scale, no servers to babysit, just files sitting on edge nodes around the world. If you don’t need to capture user data for ad-driven personalization, you don’t need the complexity of the surveillance stack. If you don’t need platform distribution, you don’t need to play platform games.&lt;&#x2F;p&gt;
&lt;p&gt;There’s another piece to this that I think most people are missing: edge computing changes what personalization can mean. The conventional wisdom is that personalization requires surveillance — you need to know everything about a user to show them relevant content. But that’s only true if personalization happens in a centralized database somewhere. If personalization happens at the edge, at the moment of request, you can adapt content to context without ever needing to know who the user is. The edge function doesn’t need a profile. It just needs to know what was asked for and what context it’s being asked in.&lt;&#x2F;p&gt;
&lt;p&gt;This is the architecture I keep thinking about: static content at the origin, edge functions that adapt it anonymously, AI agents that find and surface it based on actual relevance rather than SEO gaming. No surveillance required. No platform dependency. No scaling costs that force you into growth-at-all-costs mode.&lt;&#x2F;p&gt;
&lt;p&gt;It looks more like a reef than a fish farm.&lt;&#x2F;p&gt;
&lt;p&gt;I don’t want to oversell this. The transition, if it happens, won’t be clean. The platforms aren’t going to quietly cede control. The incentives that built the current web are still operating. And AI itself could go in directions that make things worse rather than better — there are plenty of dystopian paths from here.&lt;&#x2F;p&gt;
&lt;p&gt;But when I think about what I want to build toward, it’s that reef model. Many small, specialized nodes. Interconnected through open protocols. Resilient because distributed. Sustainable because the economics work at small scale.&lt;&#x2F;p&gt;
&lt;p&gt;This site is part of that bet. Static content, no tracking, no platform dependencies. The tools I’m working on — Sentinel, Sango, Ushio — they’re all about making edge infrastructure more accessible, making it easier to build and operate systems that are distributed and independent.&lt;&#x2F;p&gt;
&lt;p&gt;2025 was the year AI started breaking the old model. I don’t know exactly what grows in its place. But floating in that Okinawan water, watching the reef do what reefs do, I got a sense of what healthy systems look like. Diverse. Interconnected. Resilient. Not optimized for any single metric, but somehow working anyway.&lt;&#x2F;p&gt;
&lt;p&gt;That’s what I’m betting on.&lt;&#x2F;p&gt;
</description>
      </item>
      <item>
          <title>Mise ate my Makefile</title>
          <pubDate>Sun, 14 Dec 2025 00:00:00 +0000</pubDate>
          <author>Unknown</author>
          <link>https://raskell.io/articles/mise-ate-my-makefile/</link>
          <guid>https://raskell.io/articles/mise-ate-my-makefile/</guid>
          <description xml:base="https://raskell.io/articles/mise-ate-my-makefile/">&lt;h2 id=&quot;the-problem-with-project-setup&quot;&gt;The problem with project setup&lt;&#x2F;h2&gt;
&lt;p&gt;Every project starts the same. You need Ruby 3.2.1 but have 2.7. You need Node 20 but have 18. Someone wrote a Makefile that assumes GNU make but you’re on BSD. The &lt;code&gt;scripts&#x2F;&lt;&#x2F;code&gt; folder has 47 shell scripts and nobody remembers what half of them do.&lt;&#x2F;p&gt;
&lt;p&gt;I found mise. It fixed all of this.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-mise-actually-is&quot;&gt;What mise actually is&lt;&#x2F;h2&gt;
&lt;p&gt;mise started as a Rust rewrite of asdf. Then it absorbed make’s job too. Now it’s the one tool I install on every machine.&lt;&#x2F;p&gt;
&lt;p&gt;Here’s what my typical project setup looked like before:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.ruby-version&lt;&#x2F;code&gt; for rbenv&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;.nvmrc&lt;&#x2F;code&gt; for node&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Makefile&lt;&#x2F;code&gt; with 20 targets&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;scripts&#x2F;&lt;&#x2F;code&gt; with random shell scripts&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;.env.example&lt;&#x2F;code&gt; that nobody updates&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Here’s what it looks like now:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;# .mise.toml
[tools]
ruby = &amp;quot;3.2.1&amp;quot;
node = &amp;quot;20.11.0&amp;quot;
python = &amp;quot;3.12&amp;quot;

[tasks.test]
run = &amp;quot;bundle exec rspec &amp;amp;&amp;amp; npm test&amp;quot;
description = &amp;quot;Run all tests&amp;quot;

[tasks.deploy]
run = &amp;quot;kubectl apply -f k8s&amp;#x2F;&amp;quot;
depends = [&amp;quot;test&amp;quot;, &amp;quot;build&amp;quot;]

[env]
DATABASE_URL = &amp;quot;postgresql:&amp;#x2F;&amp;#x2F;localhost&amp;#x2F;myapp_dev&amp;quot;
RAILS_ENV = &amp;quot;development&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;One file. Everything works.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-fuzzy-matching-that-actually-works&quot;&gt;The fuzzy matching that actually works&lt;&#x2F;h2&gt;
&lt;p&gt;This is where mise gets interesting. You don’t need exact command names.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ mise run test     # runs the test task
$ mise run tset     # still runs test (typo forgiven)
$ mise run tst      # yep, runs test
$ mise run deploy   # runs deploy task
$ mise run dply     # runs deploy
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The fuzzy matching is smart. It weighs:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Character position (earlier matches score higher)&lt;&#x2F;li&gt;
&lt;li&gt;Consecutive matches&lt;&#x2F;li&gt;
&lt;li&gt;Word boundaries&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;I tested this with 30+ tasks in one project. It still found the right one 90% of the time with 3-4 characters.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tasks-live-where-they-should&quot;&gt;Tasks live where they should&lt;&#x2F;h2&gt;
&lt;p&gt;Instead of polluting the root with &lt;code&gt;scripts&#x2F;&lt;&#x2F;code&gt;, mise looks in &lt;code&gt;.mise&#x2F;tasks&#x2F;&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;.mise&amp;#x2F;
└── tasks&amp;#x2F;
    ├── db-reset.sh
    ├── cache-clear.sh
    └── logs-tail.sh
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Any executable in there becomes a task. No registration. No config.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ mise run db-reset    # runs .mise&amp;#x2F;tasks&amp;#x2F;db-reset.sh
$ mise run cache       # fuzzy matches to cache-clear.sh
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Shell scripts stay shell scripts. But now they’re discoverable:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ mise tasks
cache-clear   Clear all caches
db-reset      Reset database to clean state  
logs-tail     Tail production logs
test          Run all tests
deploy        Deploy to production
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;the-encryption-bit-that-matters&quot;&gt;The encryption bit that matters&lt;&#x2F;h2&gt;
&lt;p&gt;mise includes age encryption support. Not bolted on. Built in.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;# .mise.toml
[env]
DATABASE_URL = &amp;quot;postgresql:&amp;#x2F;&amp;#x2F;localhost&amp;#x2F;dev&amp;quot;
API_KEY = &amp;quot;age:SECRET_ENCRYPTED_STRING&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Set it up once:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;$ mise decrypt .mise.toml
Enter passphrase: 
$ export API_KEY=&amp;quot;actual-secret-key&amp;quot;
$ mise encrypt .mise.toml
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Your secrets are in the repo but encrypted. CI&#x2F;CD gets the age key. Developers get the age key. Random GitHub scrapers get nothing.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;integration-with-zed&quot;&gt;Integration with Zed&lt;&#x2F;h2&gt;
&lt;p&gt;This is where it gets smooth. In Zed, I set up task shortcuts:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&amp;#x2F;&amp;#x2F; .zed&amp;#x2F;tasks.json
{
  &amp;quot;tasks&amp;quot;: {
    &amp;quot;test&amp;quot;: {
      &amp;quot;command&amp;quot;: &amp;quot;mise run test&amp;quot;,
      &amp;quot;cwd&amp;quot;: &amp;quot;$WORKSPACE_ROOT&amp;quot;
    },
    &amp;quot;deploy&amp;quot;: {
      &amp;quot;command&amp;quot;: &amp;quot;mise run deploy&amp;quot;,
      &amp;quot;cwd&amp;quot;: &amp;quot;$WORKSPACE_ROOT&amp;quot;  
    }
  }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now &lt;code&gt;cmd-shift-t&lt;&#x2F;code&gt; opens the task picker. Type “te”, hit enter. Tests run. The AI assistant sees the output inline. Fixes the code. Reruns the test. No context switching.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-breaks&quot;&gt;What breaks&lt;&#x2F;h2&gt;
&lt;p&gt;mise isn’t perfect. Here’s what I hit:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Windows support&lt;&#x2F;strong&gt;: Works through WSL. Native is rough.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Legacy tools&lt;&#x2F;strong&gt;: Some older ruby&#x2F;node versions don’t install clean. Same issue asdf has.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Task dependencies&lt;&#x2F;strong&gt;: Can’t do dynamic dependencies like make. Tasks depend on fixed task names.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Fuzzy matching confusion&lt;&#x2F;strong&gt;: With tasks named &lt;code&gt;deploy-staging&lt;&#x2F;code&gt; and &lt;code&gt;deploy-production&lt;&#x2F;code&gt;, typing &lt;code&gt;deploy&lt;&#x2F;code&gt; might pick wrong. Be specific or rename.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;the-tradeoffs&quot;&gt;The tradeoffs&lt;&#x2F;h2&gt;
&lt;p&gt;What I gained:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;One tool instead of 4 (asdf, direnv, make, scripts)&lt;&#x2F;li&gt;
&lt;li&gt;Fuzzy matching saves 100s of keystrokes daily&lt;&#x2F;li&gt;
&lt;li&gt;New devs get running in 2 commands: &lt;code&gt;mise install&lt;&#x2F;code&gt; and &lt;code&gt;mise run setup&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Secrets management that doesn’t suck&lt;&#x2F;li&gt;
&lt;li&gt;Task discovery that actually works&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;What I paid:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Another tool to install (but it replaces 4)&lt;&#x2F;li&gt;
&lt;li&gt;TOML syntax (not everyone’s favorite)&lt;&#x2F;li&gt;
&lt;li&gt;Rewriting Makefiles (took an afternoon per project)&lt;&#x2F;li&gt;
&lt;li&gt;Teaching the team new patterns (took a week)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;migration-pattern&quot;&gt;Migration pattern&lt;&#x2F;h2&gt;
&lt;p&gt;If you’re moving an existing project:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Install mise: &lt;code&gt;curl https:&#x2F;&#x2F;mise.jdx.dev&#x2F;install.sh | sh&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Import existing tool versions: &lt;code&gt;mise install&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Move one make target at a time to mise tasks&lt;&#x2F;li&gt;
&lt;li&gt;Move scripts to &lt;code&gt;.mise&#x2F;tasks&#x2F;&lt;&#x2F;code&gt; gradually&lt;&#x2F;li&gt;
&lt;li&gt;Add encryption last (less disruption)&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Start with the most-used tasks. Leave the weird legacy stuff in make until later.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-i-d-do-differently&quot;&gt;What I’d do differently&lt;&#x2F;h2&gt;
&lt;p&gt;After migrating 12 projects:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Start with &lt;code&gt;.mise.toml&lt;&#x2F;code&gt;, not &lt;code&gt;.mise&#x2F;config.yaml&lt;&#x2F;code&gt;. TOML is cleaner for this.&lt;&#x2F;li&gt;
&lt;li&gt;Put all tasks in &lt;code&gt;.mise&#x2F;tasks&#x2F;&lt;&#x2F;code&gt; as shell scripts first. Move to inline tasks only when needed.&lt;&#x2F;li&gt;
&lt;li&gt;Name tasks with clear prefixes: &lt;code&gt;db-reset&lt;&#x2F;code&gt;, &lt;code&gt;cache-clear&lt;&#x2F;code&gt;, &lt;code&gt;test-unit&lt;&#x2F;code&gt;. Makes fuzzy matching more predictable.&lt;&#x2F;li&gt;
&lt;li&gt;Document the age key setup immediately. People forget.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;the-bottom-line&quot;&gt;The bottom line&lt;&#x2F;h2&gt;
&lt;p&gt;mise replaced my entire project automation stack. The Rust rewrite isn’t just faster. It’s more thoughtful. Fuzzy matching, encrypted env vars, task discovery. These aren’t features. They’re fixes for real pain.&lt;&#x2F;p&gt;
&lt;p&gt;Every new project starts with &lt;code&gt;.mise.toml&lt;&#x2F;code&gt; now. Setup takes 5 minutes instead of an hour. New developers don’t message me asking how to run tests. They just run &lt;code&gt;mise tasks&lt;&#x2F;code&gt; and figure it out.&lt;&#x2F;p&gt;
&lt;p&gt;That’s the tool working.&lt;&#x2F;p&gt;
</description>
      </item>
    </channel>
</rss>
